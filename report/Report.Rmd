---
title: "tidyMC"
subtitle: "An easy-to-use package for Monte-Carlo Simulations"
type: "Report"
author: "Ignacio Moreira Lara, Stefan Linner, Konstantin Lehmann"
discipline: "M.Sc. Econometrics"
date: "`r Sys.Date()`"
supervisor: "Jens Klenke"
secondsupervisor: "Martin C. Arnold"
studid: 230658, 233565, 229994
cols_authors: 4
estdegree_emester: "Summer Term 2022"
deadline: "06.09.2022"
output:
  pdf_document:
    keep_tex: yes
    template: template.tex
    fig_caption: yes
    citation_package: biblatex
    number_sections: false
toc: false
lot: false
lof: false
graphics: true
biblio-title: References
fontsize: 10pt
geometry: lmargin=2.5cm,rmargin=2.5cm,tmargin=2.5cm,bmargin=2.5cm
biblio-files: references.bib
classoption: a4paper
language: english
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(profvis)
library(purrr)
library(dplyr)
library(tibble)
library(rlang)
library(ggplot2)
```

# a)

```{r a}

lprob_nbinomial <- function(data, k = 10, p){
  

  - sum(log(choose(data+k-1, data))) - length(data)*k*log(p) - sum(data)*log(1-p)
  
}



set.seed(123)

data.test <- rnbinom(n = 1e3, size = 10, prob = .3)
k.test <- 10
p.test <- 0.3

bench::mark(
  {
    - sum(log(choose(data.test + k.test - 1, data.test)))
  }, 
  {
    - length(data.test)*k.test*log(p.test)
  }, 
  {
    - sum(data.test)*log(1-p.test)
  },
  check = FALSE)$median


```
In the function, the most computationally expensive calculation is the first one,
since it's composed of different functions calculated over several elements of
data.test.



# b)

An ephemeral environment is an environment that is purposefully created to only last
a limited time. In R functions usually create ephemeral execution environments, which
are garbaged after the function has run. Function factories are special in the sense 
that the execution environment of the function factory is the enclosing environment
of the functions created by the function factory. Manufactured functions behave differently
because values used to create the new functions are bound to the execution environments
of the function factory when the function was created. Every time a function is created 
via the function factory, a new, usually ephemeral, execution environment is created,
but instead of vanishing becomes the enclosing environment for the functions created


# c)

```{r c}

ll_nbinomial <- function(data, k = 10, p
){
  
  x <- as.integer(data)
  n <- length(x)
  sum_x <- sum(data)
  sum_l_choose <- sum(log(choose(x+k-1, x)))
  
  function(p){
    - sum_l_choose - n*k*log(p) - sum_x*log(1-p)
  }
}

set.seed(123)

x1 <- rnbinom(n = 1e3, size = 10, prob = .3)

test_x1 <- ll_nbinomial(data = x1)

bench::mark(
  {
    map_dbl(
      seq(from =0.1, to = 0.9, by = 0.1), 
      lprob_nbinomial, 
      data = x1, 
      k = 10
    )
  }, 
  {
    map_dbl(
      seq(from =0.1, to = 0.9, by = 0.1), 
      test_x1
    )
  }, 
  check = FALSE)$median


```
Using the local environment of the function we can store the first element of the calculation
of the likelihood since it does not depend on pi. After that, this value is reused
for the next calculations and the speed of the function is greatly improved.


# d)

```{r d}

set.seed(123)

x1 <- rnbinom(n = 1e3, size = 10, prob = .3)

test_x1 <- ll_nbinomial(data = x1)

tibble::tibble(p = seq(from =0.1, to = 0.9, by = 0.1)) %>%
  mutate(log_likelihood = map_dbl(p, test_x1))

```


# e)

```{r}


nbin_mle <- function(input_fun){
  
  opti <- optimize(input_fun, interval= c(1e-25, 1-1e-25), tol = 1e-5)
  
  fun_env <- environment(input_fun)
  
  list(
    data = fun_env$data,
    n = fun_env$n,
    distr = "negative binomial distribution",
    par = "p",
    ll = opti$objective, 
    MLE = opti$minimum, 
    fun = input_fun 
  )
}

nbin_mle(test_x1)

```

# f)

```{r}


nbin_mle <- function(input_fun){
  
  opti <- optimize(input_fun, interval= c(1e-25, 1-1e-25), tol = 1e-5)
  
  fun_env <- environment(input_fun)
  
  res <- list(
    data = fun_env$data,
    n = fun_env$n,
    distr = "negative binomial distribution",
    par = "p", 
    ll = opti$objective, 
    MLE = opti$minimum, 
    fun = input_fun
  )
  class(res) <-  "my_mle"
  res
  
}

summary.my_mle <- function(x, prob_seq){
  if (class(x) == "my_mle") {
    new <- list(
      data_summary = summary(x$data),
      prob_ll = tibble::tibble(prob = prob_seq) %>%
        mutate(ll = map_dbl(prob, x$fun))
    ) 
    out <- c(x, new)
    class(out) <- "summary.my_mle"
    return(out)
  } else {
    message("Object not of class my_mle!")
  }
}

```

# g)
```{r}

plot.summary.my_mle <- function(x){
  if (class(x) == "summary.my_mle") {
    ggplot2::ggplot(x$prob_ll, aes(y = ll, x = prob)) +
      geom_line() +
      geom_point(aes(y = x$ll, x = x$MLE), col = "red") +
      geom_segment(aes(x=x$MLE, xend=x$MLE, y=0, yend=x$ll),
                   linetype = "dashed" ) +
      labs(y = "log L(pi; x, k = 10)",
           x = "pi") +
      theme_bw() + 
      scale_x_continuous(expand = c(0, 0), 
                         limits = c(0, 1.05),
                         breaks = c(0,0.25,0.5,0.75,1)) + 
      scale_y_continuous(expand = c(0, 0), 
                         limits = c(0, NA)) +
      theme(panel.border = element_blank(), 
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(), 
            axis.line = element_line(colour = "black")
      )
    
  } else {
    message("Object not of class summary.my_mle!")
  }
}

print.summary.my_mle <- function(x){
  if (class(x) == "summary.my_mle") {
    cat(
      "Summary MLE estimate for", x$distr, ":\n\n",
      "MLE estimate for", x$par, " = ", round(x$MLE,3), "\n",
      "with a log loss of", round(x$ll,3)
    )
  } else {
    message("Object not of class summary.my_mle!")
  }
}

```


# h)

```{r}

test <- summary(nbin_mle(test_x1), seq(1e-5,1-1e-5,1e-4))

plot(test)

print(test)

```

